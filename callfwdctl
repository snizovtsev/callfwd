#!/usr/bin/env python3

import socket
import array
import sys
import os
import tempfile
import datetime
import subprocess
import tarfile
import json


CALLFWD_SERVER_PATH = "/run/callfwd"
if not os.path.exists(CALLFWD_SERVER_PATH):
    XDG_RUNTIME_DIR = os.getenv("XDG_RUNTIME_DIR")
    CALLFWD_SERVER_PATH = os.path.join(XDG_RUNTIME_DIR, "callfwd")


class CallFwdControl(object):
    def __init__(self, doorbell, server=None):
        if server is None:
            server = CALLFWD_SERVER_PATH
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
        sock.bind(doorbell)
        sock.connect(server)
        self.sock = sock

    def _make_request(self, msg, fds):
        msg["stderr"] = len(fds)
        cdata = array.array("i", fds + [2])
        cmsg = (socket.SOL_SOCKET, socket.SCM_RIGHTS, cdata)
        self.sock.sendmsg([json.dumps(msg).encode('ascii')], [cmsg])

    def _wait_response(self):
        msg,_,_,_ = self.sock.recvmsg(10)
        print("Success" if msg == b'S' else 'Failure')
        if msg != b'S':
            exit(1)

    def reload_db(self, new_db):
        msg = { "cmd": "reload" }
        msg["country"] = "US"
        msg["loaded"] = str(datetime.datetime.now())
        msg["file_name"] = new_db
        msg["stdin"] = 0
        if new_db.endswith(".tar.gz"):
            with tarfile.open(new_db) as tar:
                ti = tar.next()
                msg["inner_name"] = ti.name
                msg["row_estimate"] = ti.size // 23

            shell = ["tar", "xOf", new_db, msg["inner_name"]]
            with subprocess.Popen(shell, stdout=subprocess.PIPE) as p:
                self._make_request(msg, [p.stdout.fileno()])
        else:
            msg["row_estimate"] = os.stat(new_db).st_size // 23
            with open(new_db, "r") as f:
                self._make_request(msg, [f.fileno()])
        self._wait_response()

    def verify_db(self, backup_db):
        msg = { "cmd": "verify" }
        msg["file_name"] = backup_db
        msg["stdin"] = 0
        with open(backup_db, "r") as f:
            self._make_request(msg, [f.fileno()])
        self._wait_response()

    def dump_db(self, restored_db):
        msg = { "cmd": "dump" }
        msg["file_name"] = restored_db
        msg["stdout"] = 0
        with open(restored_db, "w+") as f:
            self._make_request(msg [f.fileno()])
        self._wait_response()

    def reload_acl(self, acl):
        msg = { "cmd": "acl" }
        msg["file_name"] = acl
        msg["stdin"] = 0
        with open(acl, "r") as f:
            self._make_request(msg, [f.fileno()])
        self._wait_response()

    def status(self):
        msg = { "cmd": "meta" }
        self._make_request(msg, [])
        self._wait_response()


if __name__ == '__main__':
    with tempfile.TemporaryDirectory('callfwdctl') as tmpdir:
        doorbell = os.path.join(tmpdir, 'doorbell')
        ctl = CallFwdControl(doorbell)
        if sys.argv[1] == 'reload':
            ctl.reload_db(sys.argv[2])
        elif sys.argv[1] == 'verify':
            ctl.verify_db(sys.argv[2])
        elif sys.argv[1] == 'dump':
            ctl.dump_db(sys.argv[2])
        elif sys.argv[1] == 'acl':
            ctl.reload_acl(sys.argv[2])
        elif sys.argv[1] == 'status':
            ctl.status()
